import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { Clipboard } from '@johnlindquist/clipboard';
import { store } from '@johnlindquist/kit/core/db';
import { kitPath, tmpClipboardDir } from '@johnlindquist/kit/core/utils';
import type { Script } from '@johnlindquist/kit/types';
import { format } from 'date-fns';
import { clipboard } from 'electron';
import { debounce } from 'lodash-es';
import { nanoid } from 'nanoid';
import { Observable, type Subscription } from 'rxjs';
import { debounceTime, filter, share, switchMap } from 'rxjs/operators';
import { subscribeKey } from 'valtio/utils';
import { Trigger } from '../shared/enums';
import { emitter, KitEvent } from '../shared/events';
import { addToClipboardHistory, detectSecret, getClipboardHistory } from './clipboard';
import { registerIO } from './io';
import { deleteText } from './keyboard';
import { tickLog as log, snippetLog } from './logs';
import { prompts } from './prompts';
import shims from './shims';
import { kitClipboard, kitConfig, kitState, kitStore, subs } from './state';

type FrontmostApp = {
  localizedName: string;
  bundleId: string;
  bundlePath: string;
  executablePath: string;
  isLaunched: boolean;
  pid: number;
};

type ClipboardInfo = {
  type: 'image' | 'text' | 'ignore';
  app: FrontmostApp;
};

const frontmost: any = null;

let prevKey = -1;

// @ts-expect-error platform-dependent imports
import type { UiohookKey, UiohookKeyboardEvent, UiohookMouseEvent } from 'uiohook-napi';
import type { SnippetInfo } from '../shared/types';

let uiohookKeyCode: typeof UiohookKey;

const SPACE = '_';

function isTransient(): boolean {
  const badTypes = [
    'de.petermaurer.TransientPasteboardType',
    'com.typeit4me.clipping',
    'Pasteboard generator type',
    'com.agilebits.onepassword',
    'org.nspasteboard.TransientType',
    'org.nspasteboard.ConcealedType',
    'org.nspasteboard.AutoGeneratedType',
  ];

  for (let i = 0; i < badTypes.length; i++) {
    if (clipboard.has(badTypes[i])) {
      return true;
    }
  }
  return false;
}

const ioEvent = (event: UiohookKeyboardEvent | UiohookMouseEvent) => {
  if (!uiohookKeyCode) {
    uiohookKeyCode = shims['uiohook-napi'].UiohookKey;
  }

  try {
    if ((event as UiohookMouseEvent).button) {
      log.silly('Clicked. Clearing snippet.');
      kitState.snippet = '';
      return;
    }

    const e = event as UiohookKeyboardEvent;
    const kc = e.keycode;

    if (kc === uiohookKeyCode.Escape) {
      kitState.typedText = '';
      if (kitState.isTyping) {
        log.info('‚úã Cancel typing');
        kitState.cancelTyping = true;
      }
    }

    if (kitState.isTyping) {
      kitState.snippet = '';
      log.silly('Ignoring snippet while Kit.app typing');
      return;
    }

    kitState.isShiftDown = e.shiftKey;

    let key: string;
    try {
      key = (event as any).key as string;
      snippetLog.silly(`key: ${key} code: ${kc}`);
    } catch (error) {
      snippetLog.error(error);
      kitState.snippet = '';
      return;
    }

    if (
      kc === uiohookKeyCode.ArrowLeft ||
      kc === uiohookKeyCode.ArrowRight ||
      kc === uiohookKeyCode.ArrowUp ||
      kc === uiohookKeyCode.ArrowDown
    ) {
      snippetLog.silly('Ignoring arrow key and clearing snippet');
      kitState.snippet = '';
      kitState.typedText = '';
      return;
    }

    if (kc === uiohookKeyCode.Shift || kc === uiohookKeyCode.ShiftRight) {
      snippetLog.silly('Ignoring shift key');
      return;
    }

    if (e.metaKey || e.ctrlKey || e.altKey) {
      snippetLog.silly('Ignoring modifier key and clearing snippet');
      kitState.snippet = '';
      if (kc === uiohookKeyCode.Backspace) {
        kitState.typedText = '';
      }
      return;
    }

    if (kc === uiohookKeyCode.Backspace) {
      snippetLog.silly('Backspace: Removing last character from snippet');
      kitState.snippet = kitState.snippet.slice(0, -1);
      kitState.typedText = kitState.typedText.slice(0, -1);
    } else if (kc === uiohookKeyCode.Space) {
      snippetLog.silly('Space: Adding space to snippet');
      if (prevKey === uiohookKeyCode.Backspace || kitState.snippet.length === 0) {
        snippetLog.silly('Clearing snippet because of backspace or empty snippet');
        kitState.snippet = '';
      } else {
        kitState.snippet += SPACE;
        kitState.typedText += ' ';
      }
    } else if (kc === uiohookKeyCode.Quote || key.length > 1 || key === '') {
      snippetLog.silly('Clearing snippet because of quote or empty key');
      kitState.snippet = '';
      kitState.typedText += key;
    } else {
      kitState.snippet += key;
      // Compute next typed buffer from the previous value and enforce an optional max length
      const prev = kitState.typedText || '';
      const tt = prev + key;
      const tl = tt.length;
      const limit = Number.isFinite(kitState.typedLimit) ? kitState.typedLimit : 0;
      kitState.typedText = limit > 0 && tl > limit ? tt.slice(-limit) : tt;
      snippetLog.silly('kitState.snippet = ', kitState.snippet);
    }
    prevKey = kc;
  } catch (error) {
    log.error(error);
  }
};

let io$Sub: Subscription | null = null;
let clipboard$Sub: Subscription | null = null;

export const preStartConfigureInterval = async () => {
  if (!kitClipboard.store) {
    try {
      kitClipboard.store = await store(kitPath('db', 'clipboard.json'), {
        history: [],
      });

      log.info(`üìã Clipboard store initialized: ${typeof kitClipboard.store}`);

      await getClipboardHistory();
    } catch (error) {
      log.error(error);
    }
  }
  if (kitStore.get('accessibilityAuthorized')) {
    log.info('üíª Accessibility authorized ‚úÖ');
    await startClipboardMonitor();
  }
};

export const startKeyboardMonitor = async () => {
  if (kitState.kenvEnv?.KIT_KEYBOARD === 'false') {
    log.info('üîá Keyboard monitor disabled');
    if (io$Sub) {
      io$Sub.unsubscribe();
    }
    return;
  }

  const io$ = new Observable((observer) => {
    log.info('Creating new Observable for uiohook-napi...');
    try {
      log.info('Attempting to start uiohook-napi...');

      registerIO(observer.next.bind(observer)).then(() => {
        log.info('üü¢ Started keyboard and mouse watcher');
      });
    } catch (e) {
      log.error('üî¥ Failed to start keyboard and mouse watcher');
      log.error(e);
      observer.unsubscribe();
    }

    return () => {
      log.info('üõë Attempting to stop keyboard and mouse watcher');
      const { uIOhook } = shims['uiohook-napi'];
      uIOhook.stop();
      log.info('üõë Successfully stopped keyboard and mouse watcher');
    };
  }).pipe(share());

  if (!io$Sub) {
    io$Sub = io$.subscribe(ioEvent as any);
  }
};

export const startClipboardMonitor = async () => {
  if (kitState.kenvEnv?.KIT_CLIPBOARD === 'false') {
    log.info('üîá Clipboard monitor disabled');
    if (clipboard$Sub) {
      clipboard$Sub.unsubscribe();
    }
    return;
  }
  log.info('‚åöÔ∏è Configuring interval...');
  if (!kitState.supportsNut) {
    log.info('üõë Keyboard watcher not supported on this platform');
    return;
  }

  log.info('Initializing üñ± mouse and ‚å®Ô∏è keyboard watcher');

  if (kitState.isMac) {
    try {
      log.info(shims['@johnlindquist/mac-frontmost'].getFrontmostApp());
    } catch (e) {
      log.warn(e);
    }
  }

  const clipboardText$ = new Observable<string>((observer) => {
    log.info('Creating new Observable for clipboard...');
    try {
      log.info('Attempting to start clipboard...');

      if (kitState.isMac) {
        log.info('Attempting to start @johnlindquist/mac-clipboard-listener...');
        shims['@johnlindquist/mac-clipboard-listener'].start();

        const onImageChange = debounce(
          () => {
            log.info('@johnlindquist/mac-clipboard-listener image changed...');
            observer.next('image');
          },
          100,
          { leading: true },
        );

        const onTextChange = debounce(
          () => {
            log.info('@johnlindquist/mac-clipboard-listener text changed...');
            observer.next('text');
          },
          100,
          { leading: true },
        );

        shims['@johnlindquist/mac-clipboard-listener'].onClipboardImageChange(onImageChange);
        shims['@johnlindquist/mac-clipboard-listener'].onClipboardTextChange(onTextChange);
      } else {
        const clipboardEventListener = new Clipboard();
        clipboardEventListener.on('text', () => {
          log.info('Clipboard text changed...');
          observer.next('text');
        });

        clipboardEventListener.on('image', () => {
          log.info('Clipboard image changed...');
          observer.next('image');
        });

        clipboardEventListener.listen();

        return () => {
          log.info('üõë Attempting to stop clipboard watcher');
          clipboardEventListener.close();
          log.info('üõë Successfully stopped clipboard watcher');
        };
      }
    } catch (e) {
      log.error('üî¥ Failed to start clipboard watcher');
      log.error(e);
    }
  }).pipe(
    // biome-ignore lint/suspicious/useAwait: need to return a promise
    switchMap(async (type: string) => {
      if (kitState.isMac && frontmost) {
        try {
          const frontmostApp = frontmost();
          return { type, app: frontmostApp };
        } catch (error) {
          log.warn(error);
        }
      }
      return { type, app: { localizedName: 'Unknown' } };
    }),
    filter((value) => value.type !== 'ignore'),
    debounceTime(100),
  );

  if (!clipboard$Sub) {
    clipboard$Sub = clipboardText$.subscribe(async ({ type, app }: ClipboardInfo) => {
      if (isTransient()) {
        log.info('Ignoring transient clipboard');
        return;
      }

      const timestamp = format(new Date(), 'yyyy-MM-dd-hh-mm-ss');
      let maybeSecret = false;
      let secretRisk: 'none' | 'low' | 'medium' | 'high' = 'none';
      let itemName = '';
      let value = '';

      if (type === 'image') {
        try {
          log.info('Attempting to read image from clipboard...');
          const image = clipboard.readImage('clipboard');

          // Check if image is empty
          if (image.isEmpty()) {
            log.info('Empty image from clipboard. Ignoring...');
            return;
          }

          // Try JPEG first for photos (smaller), fall back to PNG for transparency
          const size = image.getSize();
          const useJpeg =
            kitState?.kenvEnv?.KIT_CLIPBOARD_IMAGE_FORMAT === 'jpeg' || (size.width > 800 && size.height > 600);
          const quality = Number.parseInt(kitState?.kenvEnv?.KIT_CLIPBOARD_IMAGE_QUALITY || '85', 10);

          let imageBuffer: Buffer;
          let extension: string;

          if (useJpeg) {
            // JPEG is much smaller for photos (typically 3-10x smaller than PNG)
            imageBuffer = image.toJPEG(quality);
            extension = 'jpg';
            log.info(`Converted to JPEG (quality: ${quality}). Size: ${imageBuffer.length} bytes`);
          } else {
            imageBuffer = image.toPNG();
            extension = 'png';
            log.info(`Converted to PNG. Size: ${imageBuffer.length} bytes`);
          }

          if (imageBuffer.length > 20 * 1024 * 1024) {
            log.info('Image size > 20MB. Ignoring...');
            return;
          }

          itemName = `${timestamp}.${extension}`;
          value = path.join(tmpClipboardDir, itemName);
          await writeFile(value, imageBuffer);

          log.info(`üì∑ Saved clipboard image: ${value} (${Math.round(imageBuffer.length / 1024)}KB)`);
        } catch (error) {
          log.error(error);
          return;
        }
      } else {
        try {
          const txt = clipboard.readText();
          const txtLen = txt.length;
          if (txtLen > (kitState?.kenvEnv?.KIT_CLIPBOARD_MAX_LENGTH || 12800)) {
            log.info(
              'Ignoring clipboard value > 12800 characters. Increase KIT_CLIPBOARD_MAX_LENGTH to allow larger values.',
            );
            return;
          }
          const ignoreRegex = kitState?.kenvEnv?.KIT_CLIPBOARD_IGNORE_REGEX;
          if (ignoreRegex && txt.match(ignoreRegex)) {
            log.info('Ignoring clipboard value that matches KIT_CLIPBOARD_IGNORE_REGEX');
            return;
          }
          value = txt;
          const trimmed = txt.trim();
          const endIndex = trimmed.length > 40 ? 40 : trimmed.length;
          itemName = trimmed.slice(0, endIndex);
        } catch (error) {
          log.warn(error);
          return;
        }

        // Use enhanced secret detection with Shannon entropy and pattern matching
        const secretDetection = detectSecret(value);
        maybeSecret = secretDetection.maybeSecret;
        secretRisk = secretDetection.risk;

        // Also check user-defined secret regex
        if (!maybeSecret && kitState?.kenvEnv?.KIT_MAYBE_SECRET_REGEX) {
          try {
            if (value.match(new RegExp(kitState.kenvEnv.KIT_MAYBE_SECRET_REGEX))) {
              maybeSecret = true;
              secretRisk = 'medium';
            }
          } catch (e) {
            log.warn('Invalid KIT_MAYBE_SECRET_REGEX:', e);
          }
        }

        if (maybeSecret) {
          log.info(`üîê Secret detected (risk: ${secretRisk}): ${secretDetection.matchedPattern || 'entropy-based'}`);
        }
      }

      // Extract source application info
      const sourceApp = prompts?.prevFocused ? 'Script Kit' : app?.localizedName || 'Unknown';
      const clipboardItem = {
        id: nanoid(),
        name: itemName,
        description: `${sourceApp} - ${timestamp}`,
        value,
        type,
        timestamp,
        maybeSecret,
        secretRisk,
        sourceApp,
        pinned: false,
      };

      addToClipboardHistory(clipboardItem);
    });
  }
};

export const startClipboardAndKeyboardWatchers = async () => {
  await new Promise((resolve) => setTimeout(resolve, 500));
  startClipboardMonitor();
  startKeyboardMonitor();
  startSnippetHealthCheck();
};

export const snippetMap = new Map<string, SnippetInfo>();
const snippetPrefixIndex = new Map<string, string[]>();

// Secure debug logging - sanitizes buffer content to avoid keylogging vulnerabilities
const SNIPPET_DEBUG = () => kitState.kenvEnv?.KIT_SNIPPET_DEBUG === 'true';

function sanitizedSnippetLog(message: string, bufferLength?: number, lastChar?: string, matchedSnippet?: string) {
  if (!SNIPPET_DEBUG()) return;
  const sanitizedInfo: Record<string, unknown> = { message };
  if (bufferLength !== undefined) sanitizedInfo.bufferLength = bufferLength;
  if (lastChar !== undefined) sanitizedInfo.lastChar = lastChar.length === 1 ? lastChar : '[multi]';
  if (matchedSnippet !== undefined) sanitizedInfo.matchedSnippet = matchedSnippet;
  snippetLog.info('[DEBUG]', sanitizedInfo);
}

// Shadow detection - warns when a new snippet key would shadow existing keys
export interface SnippetShadowWarning {
  type: 'shadows' | 'shadowed_by';
  newKey: string;
  existingKey: string;
  filePath: string;
}

export function detectSnippetShadows(newKey: string, newFilePath: string): SnippetShadowWarning[] {
  const warnings: SnippetShadowWarning[] = [];

  for (const [existingKey, existingInfo] of snippetMap) {
    // Skip if same file (re-registration)
    if (existingInfo.filePath === newFilePath) continue;

    // Check if new key shadows existing (new is prefix of existing)
    if (existingKey.startsWith(newKey) && existingKey !== newKey) {
      warnings.push({
        type: 'shadows',
        newKey,
        existingKey,
        filePath: existingInfo.filePath,
      });
    }

    // Check if new key would be shadowed by existing (existing is prefix of new)
    if (newKey.startsWith(existingKey) && newKey !== existingKey) {
      warnings.push({
        type: 'shadowed_by',
        newKey,
        existingKey,
        filePath: existingInfo.filePath,
      });
    }
  }

  return warnings;
}

function logSnippetShadowWarnings(warnings: SnippetShadowWarning[]) {
  for (const warning of warnings) {
    if (warning.type === 'shadows') {
      snippetLog.warn(
        `‚ö†Ô∏è Snippet "${warning.newKey}" will shadow "${warning.existingKey}" - ` +
          `"${warning.existingKey}" will become unreachable. File: ${warning.filePath}`,
      );
    } else {
      snippetLog.warn(
        `‚ö†Ô∏è Snippet "${warning.newKey}" is shadowed by existing "${warning.existingKey}" - ` +
          `"${warning.newKey}" may never trigger. File: ${warning.filePath}`,
      );
    }
  }
}

// Health check - validates snippet index integrity
export function validateSnippetIndexIntegrity(): { valid: boolean; orphanedKeys: string[]; missingKeys: string[] } {
  const orphanedKeys: string[] = [];
  const missingKeys: string[] = [];

  // Check for keys in prefix index that don't exist in main map
  for (const [, keys] of snippetPrefixIndex) {
    for (const key of keys) {
      if (!snippetMap.has(key)) {
        orphanedKeys.push(key);
      }
    }
  }

  // Check for keys in main map that aren't in prefix index
  for (const key of snippetMap.keys()) {
    const kl = key.length;
    const prefix = kl === 2 ? key : key.slice(-3);
    const indexedKeys = snippetPrefixIndex.get(prefix);
    if (!indexedKeys || !indexedKeys.includes(key)) {
      missingKeys.push(key);
    }
  }

  const valid = orphanedKeys.length === 0 && missingKeys.length === 0;

  if (!valid) {
    snippetLog.warn('Snippet index integrity check failed:', { orphanedKeys, missingKeys });
  }

  return { valid, orphanedKeys, missingKeys };
}

export function updateSnippetPrefixIndex() {
  snippetPrefixIndex.clear();
  const keys = snippetMap.keys();
  for (const key of keys) {
    const kl = key.length;
    // For snippets of 2 chars, index under 2-char prefix
    // For snippets of 3+ chars, index under 3-char prefix
    // This ensures we can find short snippets like ",,"
    if (kl === 2) {
      // Store 2-char snippets under their full key
      let arr = snippetPrefixIndex.get(key);
      if (!arr) {
        arr = [];
        snippetPrefixIndex.set(key, arr);
      }
      arr.push(key);
    } else {
      // Store 3+ char snippets under their last 3 chars
      const prefix = key.slice(-3);
      let arr = snippetPrefixIndex.get(prefix);
      if (!arr) {
        arr = [];
        snippetPrefixIndex.set(prefix, arr);
      }
      arr.push(key);
    }
  }
}

const subSnippet = subscribeKey(kitState, 'snippet', async (snippet: string) => {
  const sl = snippet.length;

  // Sanitized debug logging - only logs length and last char, not full buffer (keylog safe)
  sanitizedSnippetLog('Buffer update', sl, sl > 0 ? snippet.slice(-1) : undefined);

  if (sl < 2) {
    return;
  }

  // Check both 2-char and 3-char prefixes to find all possible snippet matches
  const prefixesToCheck: string[] = [];
  if (sl >= 2) {
    prefixesToCheck.push(snippet.slice(-2));
  }
  if (sl >= 3) {
    prefixesToCheck.push(snippet.slice(-3));
  }

  // Collect all potential snippet keys from all prefixes
  const potentialSnippetKeys = new Set<string>();
  for (const prefix of prefixesToCheck) {
    const keys = snippetPrefixIndex.get(prefix);
    if (keys) {
      for (const key of keys) {
        // Double-check the key still exists in the main map
        if (snippetMap.has(key)) {
          potentialSnippetKeys.add(key);
        }
      }
    }
  }

  // Sanitized debug log - show number of potential matches, not keys
  if (potentialSnippetKeys.size > 0) {
    sanitizedSnippetLog('Potential matches found', sl, snippet.slice(-1), `${potentialSnippetKeys.size} candidates`);
  }

  // Check if the typed text ends with any of the snippet keys
  for (const snippetKey of potentialSnippetKeys) {
    if (snippet.endsWith(snippetKey)) {
      sanitizedSnippetLog('Snippet matched', sl, snippet.slice(-1), snippetKey);
      log.info(`Running snippet: ${snippetKey}`);
      const script = snippetMap.get(snippetKey);
      if (!script) {
        log.warn(`Snippet key "${snippetKey}" found in index but not in map. This should not happen. Skipping.`);
        // Clean up the stale index entry
        updateSnippetPrefixIndex();
        continue;
      }
      log.info('script', script, { snippetKey });
      const postfix = script.postfix;

      if (kitConfig.deleteSnippet) {
        const stringToDelete = postfix ? snippet : snippetKey;
        log.info({ stringToDelete, postfix });
        kitState.snippet = '';
        log.info('Before deleteText', { stringToDelete });
        await deleteText(stringToDelete);
        log.info('After deleteText', { stringToDelete });
      }

      const args = postfix ? [snippet.slice(0, snippet.length - snippetKey.length)] : [];
      const options = {
        force: false,
        trigger: Trigger.Snippet,
      };

      if (script.txt || script.filePath.endsWith('.txt')) {
        log.info(`Running text snippet: ${script.filePath}`);
        emitter.emit(KitEvent.RunPromptProcess, {
          scriptPath: kitPath('app', 'paste-snippet.js'),
          args: [...args, '--filePath', script.filePath],
          options,
        });
      } else {
        log.info(`Running scriptlet snippet: ${script.filePath}`);
        emitter.emit(KitEvent.RunPromptProcess, {
          scriptPath: script.filePath,
          args,
          options,
        });
      }
    }
  }

  if (snippet.endsWith(SPACE)) {
    kitState.snippet = '';
  }
});

const subIsTyping = subscribeKey(kitState, 'isTyping', () => {
  log.silly(`üìï isTyping: ${kitState.isTyping ? 'true' : 'false'}`);
});

const snippetRegex = /^(?:\/\/|#)\s{0,2}([\w-]+):\s*(.*)/;
function parseSnippet(contents: string): {
  metadata: Record<string, string>;
  snippet: string;
} {
  const lines = contents.split('\n');
  const metadata: Record<string, string> = {};
  let snippetStartIndex = lines.length;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const match = line.match(snippetRegex);
    if (match) {
      metadata[match[1].trim().toLowerCase()] = match[2].trim();
    } else {
      snippetStartIndex = i;
      break;
    }
  }

  const snippet = lines.slice(snippetStartIndex).join('\n');
  return { metadata, snippet };
}

export const addTextSnippet = async (filePath: string) => {
  log.verbose(`Adding text snippet: ${filePath}`);
  // Remove if already added
  {
    const keys = snippetMap.keys();
    const toDelete: string[] = [];
    for (const key of keys) {
      const val = snippetMap.get(key);
      if (val && val.filePath === filePath && val.txt) {
        toDelete.push(key);
      }
    }
    for (let i = 0; i < toDelete.length; i++) {
      snippetMap.delete(toDelete[i]);
    }
  }

  // File system resilience - wrap file read in try/catch
  let contents: string;
  try {
    contents = await readFile(filePath, 'utf8');
  } catch (error) {
    // File may have been deleted, moved, or locked - remove from index silently
    snippetLog.warn(`Failed to read snippet file, removing from index: ${filePath}`, error);
    updateSnippetPrefixIndex();
    return;
  }

  const { metadata } = parseSnippet(contents);

  let expand = metadata?.snippet || metadata?.expand;
  if (expand) {
    let postfix = false;
    if (expand.startsWith('*')) {
      postfix = true;
      expand = expand.slice(1);
    }

    // Shadow detection - warn about conflicts before registration
    const shadows = detectSnippetShadows(expand, filePath);
    if (shadows.length > 0) {
      logSnippetShadowWarnings(shadows);
    }

    log.info(`Mapped snippet: ${expand} to ${filePath}`);
    snippetMap.set(expand, {
      filePath,
      postfix,
      txt: true,
    });
  }
  updateSnippetPrefixIndex();
  log.info(`Text snippet: Current snippet map: ${JSON.stringify(Object.fromEntries(snippetMap), null, 2)}`);
};

export const snippetScriptChanged = (script: Script) => {
  // Remove if already added

  const keys = snippetMap.keys();
  const toDelete: string[] = [];
  for (const key of keys) {
    const val = snippetMap.get(key);
    if (val && val.filePath === script.filePath && !val.txt) {
      snippetLog.info(`Adding snippet key to remove: ${key}`);
      toDelete.push(key);
    }
  }
  for (let i = 0; i < toDelete.length; i++) {
    snippetLog.info(`Removing snippet key: ${toDelete[i]}`);
    snippetMap.delete(toDelete[i]);
  }

  const expand = script?.expand || script?.snippet;

  if (script?.kenv !== '' && !kitState.trustedKenvs.includes(script?.kenv)) {
    if (expand) {
      snippetLog.info(`Ignoring ${script?.filePath} // Snippet metadata because it's not trusted.`);
      snippetLog.info(`Add "${kitState.trustedKenvsKey}=${script?.kenv}" to your .env file to trust it.`);
    }
    return;
  }

  if (expand) {
    snippetLog.info(`‚úÇÔ∏è Set expansion: ${expand}`);
    let postfix = false;
    let exp = expand;
    if (exp.startsWith('*')) {
      postfix = true;
      exp = exp.slice(1);
    }

    // Shadow detection - warn about conflicts before registration
    const shadows = detectSnippetShadows(exp, script.filePath);
    if (shadows.length > 0) {
      logSnippetShadowWarnings(shadows);
    }

    snippetLog.info(`Mapped snippet: ${exp} to ${script.filePath}`);
    snippetMap.set(exp, {
      filePath: script.filePath,
      postfix,
      txt: false,
    });
  }

  updateSnippetPrefixIndex();
  snippetLog.info(`Standard Snippet: Current snippet map: ${JSON.stringify(Object.fromEntries(snippetMap), null, 2)}`);
};

export const removeSnippet = (filePath: string) => {
  const keys = snippetMap.keys();
  const toDelete: string[] = [];
  for (const key of keys) {
    const val = snippetMap.get(key);
    if (val && val.filePath === filePath) {
      toDelete.push(key);
    }
  }
  for (let i = 0; i < toDelete.length; i++) {
    snippetMap.delete(toDelete[i]);
  }
  updateSnippetPrefixIndex();
};

subs.push(subSnippet, subIsTyping);

// Periodic health check - validates snippet index integrity hourly
const HEALTH_CHECK_INTERVAL_MS = 60 * 60 * 1000; // 1 hour
let healthCheckInterval: ReturnType<typeof setInterval> | null = null;

export function startSnippetHealthCheck() {
  if (healthCheckInterval) {
    clearInterval(healthCheckInterval);
  }

  healthCheckInterval = setInterval(() => {
    const { valid, orphanedKeys, missingKeys } = validateSnippetIndexIntegrity();

    if (!valid) {
      snippetLog.warn('Snippet health check: index integrity issues detected, rebuilding index');
      // Auto-heal by rebuilding the index
      updateSnippetPrefixIndex();

      // Re-validate after rebuild
      const recheck = validateSnippetIndexIntegrity();
      if (recheck.valid) {
        snippetLog.info('Snippet health check: index rebuilt successfully');
      } else {
        snippetLog.error('Snippet health check: index still invalid after rebuild', {
          orphanedKeys: recheck.orphanedKeys,
          missingKeys: recheck.missingKeys,
        });
      }
    } else {
      snippetLog.silly('Snippet health check: index integrity OK');
    }
  }, HEALTH_CHECK_INTERVAL_MS);

  // Run initial check on startup (delayed by 30 seconds to let snippets load)
  setTimeout(() => {
    validateSnippetIndexIntegrity();
  }, 30000);
}

export function stopSnippetHealthCheck() {
  if (healthCheckInterval) {
    clearInterval(healthCheckInterval);
    healthCheckInterval = null;
  }
}
